'''
Created on Thu Apr 20 19:20:43 2017
@author: riddhisw

.. module:: gpr.GPRP_risk_analysis

    :synopsis: Calculates GPy predictions and tunes algorithms
         according to lowest Bayes Risk.

    Module Level Classes:
    --------------------
        GPRP_Optimisation : Calculates GPy predictions using L-BFGF-B optimiser to
            tune kernel hyper-parameters.

.. moduleauthor:: Riddhi Gupta <riddhi.sw@gmail.com>

'''
from __future__ import division, print_function, absolute_import

import sys
import numpy as np
import GPy # Non standard Python package

from data_tools.load_raw_cluster_data import LoadExperiment as le
from gpr.common import get_data
from analysis_tools.common import sqr_err

class GPRPOptimisation(object):
    '''
    Calculates GPy predictions using L-BFGF-B optimiser to tune kernel
    hyper-parameters.

    Attributes:
    ----------
        test_case (`int`) : Index value to label parameter regimes, as
            in KalmanParameterRegimes.ods.
        variation (`int`) : Index value to label scanning parameter in a global
            fixed parameter regime, as in KalmanParameterRegimes.ods.
        LKFFBfilepath (`str`) : Filepath to .npz database of engineered true noise
            realisations, corresponding to regime labelled via (test_case, variation).
        GPRP_savetopath (`str`) : Savepath for the GPR output generated by
            GPRPOptimisation.make_GPR_PER as .npz file.
        dataobject (`class object`): A data_tools.load_raw_cluster_data.LoadExperiment instance.
        Sigma_Max (`float64`): Maximal bound for sigma in L-BFGS-B optimiser in GPy.
        R_Max (`float64`): Maximal bound for R in L-BFGS-B optimiser in GPy.

    Methods:
    -------
        initialise_GPR_hyperparams : Return initial values for L-BFGF-S in GPy.
        call_GPy_optimise : Return optimised GPy model.
        one_GPRP_model : Returns GPRP predictions for one truth, dataset,
            and GPRP initialisation.
        make_GPR_PER : Save L-BFGS-B optimised GPR predictions dataset as .npz file
            for ensemble of runs using a Periodic Kernel.
    '''
    def __init__(self, test_case, variation,
                 Sigma_Max, R_Max,
                 LKFFBfilepath, GPRP_savetopath):

        self.test_case = test_case
        self.variation = variation
        self.LKFFBfilepath = LKFFBfilepath
        self.GPRP_savetopath = GPRP_savetopath

        self.dataobject = le(self.test_case, self.variation,
                             GPRP_load='No',
                             LKFFB_load='Yes',
                             LKFFB_path=self.LKFFBfilepath,
                             AKF_load='No',
                             LSF_load='No')

        self.Sigma_Max = Sigma_Max
        self.R_Max = R_Max


    def initialise_GPR_hyperparams(self, approx_l_0=3.0):
        '''
        Return initial values for L-BFGF-S in GPy.

        Parameters:
        ----------
            approx_l_0 (`float64', optional) : Approximates the order of the
                lengthscale in the periodic kernel, l_0, proportional to the time
                between consecutie measurements, Delta_T_Sampling.

        Note:
        ----
            SigmaMax, R_Max : Guessed manually; or via LKFFB Kalman values.
                GPy L-BFGS-B maxes out at boundaries. SigmaMax, R_Max chosen such
                that predictions look sensible (manual tuning). Further, Sigma_Max,
                R_Max are chosen s.t. p* from GPy is approx p_0, defined above.
                -- replace with a better approach --
            Delta_T_Sampling : Defined in analysis_tools.experiment.
            n_train : Defined in analysis_tools.experiment.

        Returns:
        -------
            sigma_0 : randomly sampled process noise variance strength.
            R_0 : randomly sampled measurement noise variance strength.
            l_0 : theoretically bounded on order of approx_l_0 * Delta_T_Sampling.
            p_0 : theoretically bounded on order of n_train.

        '''
        # By theory-led approximations:
        p_0 = self.dataobject.Expt.n_train
        l_0 = self.dataobject.Expt.Delta_T_Sampling * approx_l_0
        # By randomly chosing value between (0, max], where max == L-BFGFS Bound, tuned manually:
        sigma_0 = np.random.uniform(low=0.1, high=self.Sigma_Max)
        R_0 = np.random.uniform(low=0.1, high=self.R_Max)
        return sigma_0, R_0, p_0, l_0

    def call_GPy_optimise(self, X, Y, sigma_0, R_0, p_0, l_0,
                          sigma_bound=0,
                          R_bound=0,
                          input_dim=1,
                          messages=False,
                          optimizer=None):
        ''' Return optimised GPy model, given dataset, kernel, and optimisation bounds.
        Optimiser defaults to lbfgs.

        Parameters:
        ----------
            X (`float64`) :  Time labels for measurement record.
            Y (`float64`) :  Measurement record.
            sigma_0 (`float64`) : randomly sampled initial condition for GPy optimiser.
                Set by GPRPOptimisation.initialise_GPR_hyperparams.
            R_0 (`float64`) : randomly sampled initial condition for GPy optimiser.
                Set by GPRPOptimisation.initialise_GPR_hyperparams.
            p_0 (`float64`) : theoretically approximated initial condition for GPy optimiser.
                Set by GPRPOptimisation.initialise_GPR_hyperparams.
            l_0 (`float64`) : theoretically approximated initial condition for GPy optimiser.
                Set by GPRPOptimisation.initialise_GPR_hyperparams.

            sigma_bound (`float64`) : Maximal bound on process noise variance.
                Defaults to GPRPOptimisation.Sigma_Max.
            R_bound (`float64`) : Maximal bound on measurement noise variance.
                Defaults to GPRPOptimisation.R_Max.
            input_dim (`float64`) : Dimensionality of periodic kernel. Defaults to 1.
            messages (`Boolean`) : Display messages during optimisation. Defaults to False.
            optimizer (`str`) : Preferred GPy optimiser. Defaults to None / lbfgs.

        Returns:
        -------
            m1 : Optimised GPR model with periodic kernel. (GPy.core.GP object).
        '''

        if sigma_bound == 0:
            sigma_bound = self.Sigma_Max

        if R_bound == 0:
            R_bound = self.R_Max

        kernel_per = GPy.kern.StdPeriodic(input_dim, period=p_0, variance=sigma_0, lengthscale=l_0)
        gauss = GPy.likelihoods.Gaussian(variance=R_0)
        exact = GPy.inference.latent_function_inference.ExactGaussianInference()

        # Initiate GPR model
        m1 = GPy.core.GP(X=X, Y=Y, kernel=kernel_per, likelihood=gauss, inference_method=exact)
        m1.std_periodic.variance.constrain_bounded(0, sigma_bound)
        m1.Gaussian_noise.variance.constrain_bounded(0, R_bound)

        # Optimise GPR model
        # Defaults to preferred optimiser if optimizer=None, preferred optimiser == lbfgsb
        m1.optimize(optimizer=optimizer, messages=messages)
        return m1

    def one_GPRP_model(self, training_pts, approx_l_0, randdata, messages=False, optimizer=None):
        '''
        Returns GPRP predictions for one truth, dataset, and GPRP initialisation.
        [Helper Function].

        Parameters:
        ----------
            training_pts (`int`) : Number of time labels chosen for GPR analysis.
            approx_l_0 (`float64') : Approximates the order of the lengthscale in
                the periodic kernel, l_0, proportional to the time between
                consecutive measurements.
            randdata (`str`): A Yes (`y`) / No (`n`) flag to randomize choice of time labels.
            messages : Display messages during GPy optimisation. Defaults to False.
            optimizer : Preferred GPy optimiser. Defaults to None / lbfgs.

        Returns:
        -------
            predictions (`float64`) : Single run of predictions from tuned GPR model.
            truth (`float64`) : True noise realisation used to generate measurements.
            msmts (`float64`) : Noisy measurements (input to filtering).
            opt_params_list (`float64`) : List of optimally tuned parameters.
            init_params_list (`float64`) : List of initial conditions (theory and/or random).
            m1 (`GPy object`) : Tuned GPy GPR model with Periodic Kernel (GPy.core.GP object).

        See Also:
        -------
            gpr.common.get_data
            GPRPOptimisation.initialise_GPR_hyperparams
            GPRPOptimisation.call_GPy_optimise

        '''
        X, Y, testx, truth, msmts  = get_data(self.dataobject, 
                                              points=training_pts,
                                              randomize=randdata)

        sigma_0, R_0, p_0, l_0 = self.initialise_GPR_hyperparams(approx_l_0=approx_l_0)

        init_params_list = [sigma_0, R_0, p_0, l_0]
        m1 = self.call_GPy_optimise(X, Y, sigma_0, R_0, p_0, l_0, messages=messages, optimizer=optimizer)
        opt_params_list = [m1.std_periodic.variance[0], m1.Gaussian_noise.variance[0], m1.std_periodic.period[0], m1.std_periodic.lengthscale[0]]

        predictions = m1.predict(testx)[0].flatten()

        return predictions, truth, msmts, opt_params_list, init_params_list, m1


    def make_GPR_PER(self, mapname='_GPR_PER_', approx_l_0=3.0, randdata='y'):
        ''' Save L-BFGS-B optimised GPR predictions dataset for ensemble of runs
            using a Periodic Kernel as a .npz file.

            Parameters:
            ----------
                mapname (`str`, optional) : Filename for saving .npz output.
                approx_l_0 (`float64', optional) : Approximates the order of the lengthscale in
                    the periodic kernel, l_0, proportional to the time between
                    consecutive measurements.
                randdata (`str`, optional): A Yes (`y`) / No (`n`) flag to randomize choice
                    of time labels.
            Returns:
            -------
                Saves .npz file with L-BFGS-B optimised GPR (Periodic Kernel) predictions dataset.
        '''

        path2dir = self.GPRP_savetopath+'test_case_'+str(self.test_case)+'_var_'+str(self.variation)

        # Comparable in size to n_train, but training points are randomly chosen
        training_pts = self.dataobject.Expt.n_train

        prediction_errors = []
        forecastng_errors = []
        macro_truth = []
        macro_data = []
        macro_opt_params = []
        macro_init_params = []

        for idx_d in xrange(self.dataobject.LKFFB_max_it_BR):

            predictions, truth, msmts, opt_params_list, init_params_list = self.one_GPRP_model(training_pts, approx_l_0, randdata)[0:5]

            truth_ = truth[self.dataobject.Expt.n_train - self.dataobject.Expt.n_testbefore : self.dataobject.Expt.n_train + self.dataobject.Expt.n_predict]
            residuals_sqr_errors = sqr_err(predictions, truth_)

            prediction_errors.append(residuals_sqr_errors[0: self.dataobject.Expt.n_testbefore])
            forecastng_errors.append(residuals_sqr_errors[self.dataobject.Expt.n_testbefore : ])
            macro_truth.append(truth)
            macro_data.append(msmts)
            macro_opt_params.append(opt_params_list)
            macro_init_params.append(init_params_list)

            np.savez(path2dir+'_GPR_PER_',
                     msmt_noise_variance=self.dataobject.LKFFB_msmt_noise_variance,
                     max_it_BR=self.dataobject.LKFFB_max_it_BR,
                     macro_truth=macro_truth,
                     GPR_opt_params=macro_opt_params,
                     macro_data=macro_data,
                     GPR_init_params=macro_init_params,
                     GPR_PER_prediction_errors=prediction_errors,
                     GPR_PER_forecastng_errors=forecastng_errors,
                     training_pts=training_pts,
                     Sigma_Max=self.Sigma_Max,
                     R_Max=self.R_Max)

        return
